Q) Which are legal

A) class X {
  var x = 99;
}

B) void doStuff(var x) { }

C) void doStuff() {
  var x;
  x = 100;
}

D) void doStuff() {
  var x = 100;
}

E) void doStuff() {
  var x = { 1, 2, 3 };
}

Q) Which are legal:

   A) void doStuff() {
     var x = new int[]{ 1, 2, 3 };
   }
B) void doStuff() {
     var [] x = new int[]{ 1, 2, 3 };
   }
C) void doStuff() {
     var x = 99;
     x = "Hello";
   }

   D) void doStuff() {
     var x = 1, y = 2;
   }

   E)
   void doStuff() {
     try {
      // stuff happens
      } catch (var ex) {
      }
   }

Q)  A)
       for (var x = 0; x < 3; x++)
         System.out.println(x);
    B)
       try (var in = new FileReader("");
            var out = new FileWriter("")) {
       }
    C)
       var var = "var";

Q)   Which print "true"
   A) String s = "Hello";
      String t = "He";
      t += "llo";
      sout(s == t);

   B) String s = "Hello";
      String t = "He";
      t += "llo";
      sout(s.equals(t));

   C) StringBuilder s = new StringBuilder("Hello");
      StringBuilder t = new StringBuilder("He");
      t.append("llo");
      sout(s.equals(t));

   D) List<String> ls = List.of("Fred", "Jim");
      List<String> ls2 = new ArrayList<>(ls);
      sout(ls.equals(ls2));

   E) LocalDate ld = LocalDate.of(2021, 3, 29);
      LocalDate ld2 = LocalDate.of(2021, 3, 29);
      sout(ld.equals(ld2));

Q) Given
   class X {
     static String h = "Hello";
   }

Which are true?
     String s1 = "Hello";
     String s2 = new StringBuilder("Hello").toString();
     String s3 = s2.intern();

A) s1 == s2
B) s2 == s3
C) s1 == s3
D) X.h == s1

Q) Given
     void doStuff() throws IOException {};
     void doStuff2() throws FileNotFoundException {};
   And:
     void tryStuff() {
       try {
         doStuff();
         doStuff2();
       } enter code here {
         // handle both exceptions
       }
     }
   What can be inserted at "enter code here"
   to provide handling of exceptions from both
   methods?
   A) catch (IOException | FileNotFoundException e)
   B) catch (FileNotFoundException | IOException e)
   C) catch (FileNotFoundException e)
   D) catch (IOException e)
   E) finally

Q)   Given:
     public class Scr {
       static int x = -1;
       public static void main(String[] args) {
         new ScrSub().doStuff();
       }
     }
and:
     class ScrSub extends Scr {
       int x = 99;
       void doStuff() {
         System.out.print(x + ","); // line n1
         int x = 100;
         System.out.print(x + ",");
         System.out.print(Scr.x + ",");
       }
     }

A) Compilation fails at line n1
B) Exception at line n1
C) 99, 100, -1
D) 0, 100, 99
E) 0, 100, -1

Q) Given:
     void doStuff(int x, int y) {}         // Method A
     void doStuff(int x, long y) {}        // Method B
     void doStuff(long x, int y) {}        // Method C
     void doStuff(int ... x) {}            // Method D
     void doStuff(Integer x, Integer y) {} // Method E

     void tryStuff() {
       doStuff(1, 2);
     }

   What happens if method A is deleted?
   A) Method B is invoked
   B) Method C is invoked
   C) Method D is invoked
   D) Method E is invoked
   E) Compilation fails

Q) Given:
     void doStuff(int x, int y) {}         // Method A
     void doStuff(int x, long y) {}        // Method B
     void doStuff(long x, int y) {}        // Method C
     void doStuff(int ... x) {}            // Method D
     void doStuff(Integer x, Integer y) {} // Method E

     void tryStuff() {
       doStuff(1, 2);
     }

What happens if methods A B and C are deleted?
A) Method D is invoked
B) Method E is invoked
C) Compilation fails

Q) Given:
class O {
  int x;
  O(int x) { this.x = x; }
  class I {
    int y;
    I(int y) { this.y = y; }
    void show() {
        System.out.println("y is " + y + " x is " + x);
    }
  }
}

what happens with this:
O.I i = new I(100);
i.show();

A) Compilation fails
B) Runtime exception is thrown
C) y is 100 x is 0
D) y is 100 x is 100
E) y is 0 x is 0


Q) Given:
     class Q25Base {
       int x = 99;
       {
         System.out.println("x is " + x);
       }
     }
     class Q25Sub extends Q25Base {
       Q25Sub(int x) {
         System.out.println("in constructor, x is " + x);
       }
       public static void go() {
         new Q25Sub(1);
       }
     }

Given a call to go(), what is the result?
   A) in constructor, x is 1
      x is 99
   B) x is 99
      in constructor, x is 1
   C) x is 99
      in constructor, x is 99
   D) Compilation fails

Q) Given
     public int getValue() {return 1;}

which of these methods may individually be added to a subclass of this class?

     A) public int getValue(int x) {return 1;}
     B) public String getValue() {return "Hello";}
     C) public String getValue(int x) {return "Hello";}

Q) Given
     class Base2 {
       void doBaseStuff() {
         System.out.println("doBaseStuff");
       }
     }

     class Sub2 extends Base2 {
       void doBaseStuff(int x) {
         System.out.println("doSubStuff");
       }
     }

In the Base2 and Sub2 classes, which are true in isolation?

     A) doBaseStuff in Base2 can be marked public without causing errors
     B) doBaseStuff in Base2 can be marked private without causing errors
     C) doBaseStuff in Sub2 can be marked public without causing errors
     D) doBaseStuff in Sub2 can be marked protected without causing errors
     E) doBaseStuff in Sub2 can be marked private without causing errors

Q) Given
     class Base2 {
       void doBaseStuff() {
         System.out.println("doBaseStuff");
       }
     }

     class Sub2 extends Base2 {
       void doBaseStuff() {
         System.out.println("doSubStuff");
       }
     }

In the Base2 and Sub2 classes, which are true in isolation?

     A) doBaseStuff in Base2 can be marked public without causing errors
     B) doBaseStuff in Base2 can be marked private without causing errors
     C) doBaseStuff in Sub2 can be marked public without causing errors
     D) doBaseStuff in Sub2 can be marked protected without causing errors
     E) doBaseStuff in Sub2 can be marked private without causing errors

Q) Given:
     class Q23Base {
       public Q23Base get() {
         return null;
       }
     }

     class Q23Sub extends Q23Base {
     }

Which methods may individually be added to this class?

   A) public Q23Base get() { return null; }
   B) public Q23Sub get() { return null; }
   C) public Runnable get() { return null; }

Q)   class Base2 {
       void doBaseStuff() {
         System.out.println("doBaseStuff");
       }
     }

     class Sub2 extends Base2 {
       void doBaseStuff() {
         System.out.println("doSubStuff");
       }
     }

In the Base2 and Sub2 classes, which are true in isolation?

   A) doBaseStuff in Base2 can be marked throws Exception without causing errors
   B) doBaseStuff in Base2 can be marked throws RuntimeException without causing errors
   C) doBaseStuff in Sub2 can be marked throws Exception without causing errors
   D) doBaseStuff in Sub2 can be marked throws RuntimeException without causing errors
   E) if doBaseStuff in Base2 were marked throws Exception,
      then doBaseStuff in Sub2 can be marked throws IOException without causing errors

Q) Given:
   interface Int1 {
     default void doStuff() {
       System.out.println("Int1.doStuff()");
     }
   }
   class Cl1 implements Int1 {
     void doStuff() {
       System.out.println("Cl1.doStuff");
     }
   }

What is the result of a call:
   new Cl1().doStuff();

   A) Compilation fails
   B) RuntimeException
   C) Int1.doStuff()
   D) Cl1.doStuff()
   E) Int1.doStuff()
      Cl1.doStuff()
Q) Given:
   interface IntA {
     default void doStuff() { System.out.println("IntA.doStuff()"); }
   }
   interface IntB {
     default void doStuff() { System.out.println("IntB.doStuff()"); }
   }

   class ClA implements IntA, IntB {
     public void doStuff() { System.out.println("ClA.doStuff"); }
   }

What is the result of a call:
   public class Q3 {
     public static void main(String[] args) { new ClA().doStuff(); }
   }

A) Compilation fails
B) RuntimeException
C) IntA.doStuff()
D) IntB.doStuff()
E) ClA.doStuff()

Q) Given:
     interface StudentCriterion {
       boolean test(Student s);
     }

and:
     class Student {
       public int getGpa() { return 0; }
       public List<String> getCourses() { return null; }
     }

Which are legal (individually):
       A) StudentCriterion sc = Student s -> { return s.getGpa() > 3;};
       B) StudentCriterion sc = s -> { s.getGpa() > 3 };
       C) Object sc = s -> {return s.getGpa() > 3;};
       D) StudentCriterion sc = (s) -> s.getGpa() > 3;
       E) StudentCriterion sc = s -> s.getCourses().size();

Q)   Which are legal individually:
     A) Function<String, String> fss = s -> { System.out.println(s); };
     B) Consumer<String> cs = s -> { System.out.println(s); };
     C) Supplier<String> ss = (s1, s2) -> s1 + s2;
     D) BiPredicate<String> bps = (String s) -> { return s.length() > 0; };
     E) ToIntFunction<String> tofs = s -> s.length();

Q) Which are correct declarations?
     A) Predicate<String> ps = s -> s.length();
     B) Predicate<String> ps = (s) -> { s.length() };
     C) Supplier<String> ss = () -> "";
     D) Function<String, Integer> len = (s, i) -> s.length() > i;
     E) ToLongFunction<String> len =  (String s) -> {
         long sum = 0;
         for (int i = 0; i < s.length(); i++) {
           sum += s.charAt(i);
         }
         return sum;
       };

Q)   Which are correct declarations?
     A) Comparator<String> cs = s1, s2 -> s2.compareTo(s1);
     B) Comparator<String> cs = (s1, s2) -> s2.compareTo(s1);
     C) Comparator<String> cs = (var s1, String s2) -> s2.compareTo(s1);
     D) Comparator<String> cs = (var s1, s2) -> s2.compareTo(s1);
     E) Comparator<String> cs = (String s1, String s2) -> s2.compareTo(s1);

Q) Given

???? (s, t) -> s.length() - t.length();

Which are correct inserted in place of ????
     A) BiFunction<String, String, Integer> f =
     B) BiPredicate<String> f =
     C) Comparator<String> f =
     D) Supplier<String, Integer> f =
     E) BinaryOperator<String> f =