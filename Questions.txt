Q) Which are legal

A) class X {
  var x = 99;
}

B) void doStuff(var x) { }

C) void doStuff() {
  var x;
  x = 100;
}

D) void doStuff() {
  var x = 100;
}

E) void doStuff() {
  var x = { 1, 2, 3 };
}

Q) Which are legal:

   A) void doStuff() {
     var x = new int[]{ 1, 2, 3 };
   }
B) void doStuff() {
     var [] x = new int[]{ 1, 2, 3 };
   }
C) void doStuff() {
     var x = 99;
     x = "Hello";
   }

   D) void doStuff() {
     var x = 1, y = 2;
   }

   E)
   void doStuff() {
     try {
      // stuff happens
      } catch (var ex) {
      }
   }

Q)  A)
       for (var x = 0; x < 3; x++)
         System.out.println(x);
    B)
       try (var in = new FileReader("");
            var out = new FileWriter("")) {
       }
    C)
       var var = "var";

Q)   Which print "true"
   A) String s = "Hello";
      String t = "He";
      t += "llo";
      sout(s == t);

   B) String s = "Hello";
      String t = "He";
      t += "llo";
      sout(s.equals(t));

   C) StringBuilder s = new StringBuilder("Hello");
      StringBuilder t = new StringBuilder("He");
      t.append("llo");
      sout(s.equals(t));

   D) List<String> ls = List.of("Fred", "Jim");
      List<String> ls2 = new ArrayList<>(ls);
      sout(ls.equals(ls2));

   E) LocalDate ld = LocalDate.of(2021, 3, 29);
      LocalDate ld2 = LocalDate.of(2021, 3, 29);
      sout(ld.equals(ld2));

Q) Given
   class X {
     static String h = "Hello";
   }

Which are true?
     String s1 = "Hello";
     String s2 = new StringBuilder("Hello").toString();
     String s3 = s2.intern();

A) s1 == s2
B) s2 == s3
C) s1 == s3
D) X.h == s1

Q) Given
     void doStuff() throws IOException {};
     void doStuff2() throws FileNotFoundException {};
   And:
     void tryStuff() {
       try {
         doStuff();
         doStuff2();
       } enter code here {
         // handle both exceptions
       }
     }
   What can be inserted at "enter code here"
   to provide handling of exceptions from both
   methods?
   A) catch (IOException | FileNotFoundException e)
   B) catch (FileNotFoundException | IOException e)
   C) catch (FileNotFoundException e)
   D) catch (IOException e)
   E) finally

Q)   Given:
     public class Scr {
       static int x = -1;
       public static void main(String[] args) {
         new ScrSub().doStuff();
       }
     }
and:
     class ScrSub extends Scr {
       int x = 99;
       void doStuff() {
         System.out.print(x + ","); // line n1
         int x = 100;
         System.out.print(x + ",");
         System.out.print(Scr.x + ",");
       }
     }

A) Compilation fails at line n1
B) Exception at line n1
C) 99, 100, -1
D) 0, 100, 99
E) 0, 100, -1

Q) Given:
     void doStuff(int x, int y) {}         // Method A
     void doStuff(int x, long y) {}        // Method B
     void doStuff(long x, int y) {}        // Method C
     void doStuff(int ... x) {}            // Method D
     void doStuff(Integer x, Integer y) {} // Method E

     void tryStuff() {
       doStuff(1, 2);
     }

   What happens if method A is deleted?
   A) Method B is invoked
   B) Method C is invoked
   C) Method D is invoked
   D) Method E is invoked
   E) Compilation fails

Q) Given:
     void doStuff(int x, int y) {}         // Method A
     void doStuff(int x, long y) {}        // Method B
     void doStuff(long x, int y) {}        // Method C
     void doStuff(int ... x) {}            // Method D
     void doStuff(Integer x, Integer y) {} // Method E

     void tryStuff() {
       doStuff(1, 2);
     }

What happens if methods A B and C are deleted?
A) Method D is invoked
B) Method E is invoked
C) Compilation fails

Q) Given:
class O {
  int x;
  O(int x) { this.x = x; }
  class I {
    int y;
    I(int y) { this.y = y; }
    void show() {
        System.out.println("y is " + y + " x is " + x);
    }
  }
}

what happens with this:
O.I i = new I(100);
i.show();

A) Compilation fails
B) Runtime exception is thrown
C) y is 100 x is 0
D) y is 100 x is 100
E) y is 0 x is 0


Q) Given:
     class Q25Base {
       int x = 99;
       {
         System.out.println("x is " + x);
       }
     }
     class Q25Sub extends Q25Base {
       Q25Sub(int x) {
         System.out.println("in constructor, x is " + x);
       }
       public static void go() {
         new Q25Sub(1);
       }
     }

Given a call to go(), what is the result?
   A) in constructor, x is 1
      x is 99
   B) x is 99
      in constructor, x is 1
   C) x is 99
      in constructor, x is 99
   D) Compilation fails